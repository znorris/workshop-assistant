# Test suite for rate limiting middleware (generated by Claude while workshop-assistant created implementation)

import pytest
import time
from unittest.mock import Mock, patch
from rate_limiter import rate_limit, redis_client, rate_limits

class TestRateLimitingMiddleware:
    
    @pytest.fixture
    def mock_request(self):
        """Mock Flask request object"""
        request = Mock()
        request.headers = {'User-Agent': 'test-user-agent'}
        request.path = '/api/v1/users'
        return request
    
    @pytest.fixture
    def clean_redis(self):
        """Clean Redis before each test"""
        redis_client.flushdb()
        yield
        redis_client.flushdb()
    
    def test_first_request_allowed(self, mock_request, clean_redis):
        """Test that first request is always allowed"""
        result = rate_limit(mock_request)
        assert result is None  # No rate limit response
    
    def test_rate_limit_enforcement(self, mock_request, clean_redis):
        """Test that rate limits are enforced correctly"""
        endpoint = '/api/v1/users'
        limit = rate_limits[endpoint]
        
        # Make requests up to the limit
        for i in range(limit):
            result = rate_limit(mock_request)
            assert result is None
        
        # Next request should be rate limited
        result = rate_limit(mock_request)
        assert result is not None
        response, status_code = result
        assert status_code == 429
        assert 'Rate limit exceeded' in response.get_json()['message']
    
    def test_different_users_separate_limits(self, clean_redis):
        """Test that different users have separate rate limits"""
        request1 = Mock()
        request1.headers = {'User-Agent': 'user1'}
        request1.path = '/api/v1/users'
        
        request2 = Mock()
        request2.headers = {'User-Agent': 'user2'}
        request2.path = '/api/v1/users'
        
        limit = rate_limits['/api/v1/users']
        
        # User1 hits the limit
        for i in range(limit):
            assert rate_limit(request1) is None
        assert rate_limit(request1) is not None  # Rate limited
        
        # User2 should still be allowed
        assert rate_limit(request2) is None
    
    def test_different_endpoints_separate_limits(self, clean_redis):
        """Test that different endpoints have separate rate limits"""
        user_request = Mock()
        user_request.headers = {'User-Agent': 'test-user'}
        user_request.path = '/api/v1/users'
        
        product_request = Mock()
        product_request.headers = {'User-Agent': 'test-user'}
        product_request.path = '/api/v1/products'
        
        # Same user, different endpoints should have separate limits
        user_limit = rate_limits['/api/v1/users']
        product_limit = rate_limits['/api/v1/products']
        
        # Hit user endpoint limit
        for i in range(user_limit):
            assert rate_limit(user_request) is None
        assert rate_limit(user_request) is not None  # Rate limited
        
        # Product endpoint should still work
        assert rate_limit(product_request) is None
    
    def test_redis_key_format(self, mock_request, clean_redis):
        """Test that Redis keys are formatted correctly"""
        rate_limit(mock_request)
        
        expected_key = f"{mock_request.headers['User-Agent']}:{mock_request.path}"
        assert redis_client.exists(expected_key)
    
    def test_expiration_time_set(self, mock_request, clean_redis):
        """Test that Redis keys have proper expiration"""
        rate_limit(mock_request)
        
        key = f"{mock_request.headers['User-Agent']}:{mock_request.path}"
        ttl = redis_client.ttl(key)
        assert ttl > 0  # Should have an expiration set
        assert ttl <= 3600  # Should be at most 1 hour
    
    @patch('rate_limiter.redis_client')
    def test_redis_connection_error_handling(self, mock_redis, mock_request):
        """Test graceful handling of Redis connection errors"""
        mock_redis.get.side_effect = Exception("Redis connection failed")
        
        # Should not raise exception, should handle gracefully
        try:
            result = rate_limit(mock_request)
            # Implementation should handle this gracefully
            # (current implementation doesn't, this test documents needed improvement)
        except Exception as e:
            pytest.fail(f"Rate limiter should handle Redis errors gracefully: {e}")
    
    def test_missing_user_agent_header(self, clean_redis):
        """Test behavior when User-Agent header is missing"""
        request = Mock()
        request.headers = {}  # No User-Agent header
        request.path = '/api/v1/users'
        
        # Should handle missing headers gracefully
        with pytest.raises(KeyError):
            rate_limit(request)
        # Note: This test shows a bug in the current implementation
    
    def test_unknown_endpoint_handling(self, clean_redis):
        """Test behavior for endpoints not in rate_limits config"""
        request = Mock()
        request.headers = {'User-Agent': 'test-user'}
        request.path = '/api/v1/unknown'
        
        # Should handle unknown endpoints gracefully
        with pytest.raises(KeyError):
            rate_limit(request)
        # Note: This test shows another improvement needed